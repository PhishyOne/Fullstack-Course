1
00:00:00,480 --> 00:00:09,360
Now in the last lesson, we managed to get our collection of NFTs to display under the section My NFTs.

2
00:00:09,900 --> 00:00:17,040
And whenever we mint a new NFT and it gets created, it's going to be loaded up when we head over to

3
00:00:17,040 --> 00:00:17,940
this route.

4
00:00:18,750 --> 00:00:25,620
Now, the next step is to be able to sell our NFTs if we wanted to, because after all, this is

5
00:00:25,620 --> 00:00:27,930
an NFT marketplace that we're creating,

6
00:00:27,930 --> 00:00:28,260
right?

7
00:00:28,800 --> 00:00:34,740
So we're going to add a little button below each NFT so we can click on it, set a price, and then

8
00:00:34,740 --> 00:00:42,300
get it to be sold on our marketplace. Which means it's going to be transferred over to the marketplace

9
00:00:42,300 --> 00:00:42,630
OpenD,

10
00:00:43,350 --> 00:00:45,720
so the OpenD can hold on to the ownership.

11
00:00:46,020 --> 00:00:51,360
And then once somebody buys that NFT then OpenD can transfer it to the buyer

12
00:00:51,600 --> 00:00:54,750
and also the buyer's money gets transferred back to us,

13
00:00:54,780 --> 00:00:56,100
the owners of the NFT.

14
00:00:56,490 --> 00:01:01,080
So a little bit convoluted and there's quite a lot of code and logic that we have to crack through.

15
00:01:01,380 --> 00:01:02,580
So let's get on with it.

16
00:01:03,300 --> 00:01:09,390
Now, the first thing we're going to do is we're going to create a button underneath our NFT cards.

17
00:01:09,930 --> 00:01:14,730
I want you to go ahead and create a new component for this. In the components folder,

18
00:01:15,060 --> 00:01:20,670
we're going to create a new button with the file name of button.jsx.

19
00:01:21,570 --> 00:01:28,800
And inside this file button.jsx, we're going to need to create a functional component, which we're

20
00:01:28,800 --> 00:01:30,060
going to call Button.

21
00:01:30,630 --> 00:01:37,560
And inside this button component, all that it's going to do is to return the HTML which I've already

22
00:01:37,560 --> 00:01:40,110
included for you in the read me file.

23
00:01:40,410 --> 00:01:46,200
So if you just go ahead and copy it, wholesale everything in there or if it's easier, you can take

24
00:01:46,200 --> 00:01:52,020
a look at it in the preview because then it gets rid of all these markdown formatting and you actually

25
00:01:52,050 --> 00:01:57,180
copy over the correct parts, which is everything between the open and closing div.

26
00:01:57,870 --> 00:02:00,330
And then we're going to paste it inside this return.

27
00:02:00,630 --> 00:02:05,280
And I've got an error here because I'm missing my parentheses for my function.

28
00:02:05,880 --> 00:02:10,650
And finally, we're going to export, default, button.

29
00:02:11,070 --> 00:02:14,660
Now, this line of code is going to require us to import React.

30
00:02:14,670 --> 00:02:21,090
So let's go ahead and copy that from another jsx file and we can paste it in here.

31
00:02:21,480 --> 00:02:26,160
We don't need the useEffect, useState so we can delete all of that.

32
00:02:26,490 --> 00:02:28,950
All we need to do is import React from react.

33
00:02:29,760 --> 00:02:34,570
Now here we've got an onClick and we've got a button name.

34
00:02:34,950 --> 00:02:41,130
Now this onClick can actually take a function that's passed in through the props.

35
00:02:41,490 --> 00:02:50,070
So we could actually have a prop that we pass in called props.handle click, which will be a function

36
00:02:50,070 --> 00:02:55,920
that's passed in here, essentially a callback that will get triggered when this onClick gets triggered.

37
00:02:56,280 --> 00:03:03,000
Now that we've got our button created, let's go back to our item.jsx and below where we've set

38
00:03:03,000 --> 00:03:04,590
our owner, set our image,

39
00:03:04,860 --> 00:03:08,160
we're going to set our button. And

40
00:03:09,150 --> 00:03:17,100
we're going to set it to that new componen, button and hopefully it should import by itself if you select

41
00:03:17,100 --> 00:03:18,060
it from the dropdown.

42
00:03:18,540 --> 00:03:25,560
And then let's close off that tag and make sure that we pass in the required props.

43
00:03:26,610 --> 00:03:29,310
The prop is called handleClick.

44
00:03:29,670 --> 00:03:35,610
So I'm just going to copy it over here and I'm going to set that equal to a function that we've got

45
00:03:35,610 --> 00:03:36,190
in here.

46
00:03:36,690 --> 00:03:39,480
So I'm going to call this function handleSell,

47
00:03:41,730 --> 00:03:44,010
because that is what it's going to do

48
00:03:44,010 --> 00:03:50,610
after all. This handleSell is going to be passed in as the callback function,

49
00:03:50,940 --> 00:03:56,750
and all we going to do for now, just to make sure that it works, is to console.log

50
00:03:57,670 --> 00:03:59,040
Sell Clicked.

51
00:03:59,940 --> 00:04:06,710
And now we've got this set button, but we don't actually have the button created.

52
00:04:06,750 --> 00:04:14,310
So I'm going to create a new state tracker called button and setButton, and then I'm going to use

53
00:04:14,310 --> 00:04:15,570
State to keep track of it.

54
00:04:16,440 --> 00:04:18,709
So where is the button going to go?

55
00:04:18,720 --> 00:04:26,010
Well, it's going to go just below this final paragraph tag right here. And now

56
00:04:26,010 --> 00:04:32,160
if we hit save and we go back to our frontend, then you should be able to see these styled buttons

57
00:04:32,160 --> 00:04:35,580
underneath each of your NFTs.

58
00:04:36,000 --> 00:04:43,380
And if I go ahead and bring up my console and click on sell, then you can see that it says Sell Clicked

59
00:04:43,380 --> 00:04:44,400
every time I click on it.

60
00:04:44,970 --> 00:04:53,040
That means we've managed to pass over this function over to our button and it gets triggered whenever

61
00:04:53,070 --> 00:04:54,480
that button gets clicked.

62
00:04:55,200 --> 00:05:00,300
So this is a really neat way of working with React when you're passing functions as props.

63
00:05:01,050 --> 00:05:06,210
Now what do we want to happen when somebody clicks on the sell button?

64
00:05:06,600 --> 00:05:11,970
Well, we want to be able to give them some sort of way of inputting how much they want to sell the

65
00:05:11,970 --> 00:05:12,930
item for.

66
00:05:13,230 --> 00:05:16,320
So what we'll need is some sort of input.

67
00:05:16,980 --> 00:05:24,150
If you head over to the README.md, you should see a section called the Price Input HTML.

68
00:05:24,630 --> 00:05:28,860
What we want to do is we want to insert it just above our button here.

69
00:05:29,130 --> 00:05:32,160
So I'm going to create something called priceInput

70
00:05:32,850 --> 00:05:36,540
and up here we're going to track its state.

71
00:05:37,110 --> 00:05:40,980
So it's priceInput and setPriceInput.

72
00:05:45,120 --> 00:05:51,750
And now if I copy my priceInput again, then I want to set it right here.

73
00:05:52,320 --> 00:05:57,210
So when handleSell is triggered, it means the sell button was clicked, right?

74
00:05:57,630 --> 00:06:07,230
So at this point we want to set the priceInput to include this new input, and we want that to show up

75
00:06:07,230 --> 00:06:08,760
right here above the button.

76
00:06:09,180 --> 00:06:16,800
And we want to create a variable with the let keyword called price, which is going to be used to display

77
00:06:16,800 --> 00:06:19,590
the value that has been entered into this input.

78
00:06:19,890 --> 00:06:26,040
And we also need to update the onChange to set this price whenever the user types into the input.

79
00:06:26,430 --> 00:06:34,380
And in the output section, we're going to set the price to equal e.target.value.

80
00:06:34,980 --> 00:06:40,770
Now normally we would probably use state for this, but because we're going to be doing a lot of asynchronous

81
00:06:40,770 --> 00:06:48,720
calls, it's not certain that the state in the input will be updated before we needed to use it to sell

82
00:06:48,720 --> 00:06:50,610
the item or to set the price.

83
00:06:51,210 --> 00:06:54,120
Now let's take a look and see what this looks like.

84
00:06:54,390 --> 00:07:02,310
So now when we click the sell button, it triggers the handle sell function, which console logs sell

85
00:07:02,310 --> 00:07:10,590
clicked. And in addition sets the priceInput from previously, which was nothing, to this input HTML

86
00:07:11,130 --> 00:07:12,270
which shows up like this.

87
00:07:12,570 --> 00:07:19,500
So we can enter a number in here, which is the price in DANG that we want to sell an FTA for.

88
00:07:20,250 --> 00:07:24,480
And now we want to be able to click on this button to confirm our price.

89
00:07:25,200 --> 00:07:27,990
That means we want to change this button up a little bit.

90
00:07:27,990 --> 00:07:34,770
We want it to have a different function for the onClick to do something else and also to change its

91
00:07:34,770 --> 00:07:43,620
text. Down here, just below where we've set our priceInput, we're going to set the button to a new button

92
00:07:43,620 --> 00:07:44,250
component.

93
00:07:45,300 --> 00:07:54,060
We want to be able to pass over the props for the button text and I want it to say confirm this time.

94
00:07:54,540 --> 00:08:01,170
Previously it should have a text attribute that says sell.

95
00:08:02,040 --> 00:08:07,410
And now once they've set the price, then I want it to say confirm.

96
00:08:08,010 --> 00:08:14,130
So now going into our button, we're going to make sure that we replace this hardcoded text with the

97
00:08:14,130 --> 00:08:19,650
props.text, which is what we set over here and over here.

98
00:08:20,250 --> 00:08:21,690
So now let's try that again.

99
00:08:21,690 --> 00:08:26,640
Initially it says Sell, but as soon as I click on it, it updates to confirm.

100
00:08:27,450 --> 00:08:33,990
In addition, I don't want it to call handleSell again because this time I actually want to make the

101
00:08:33,990 --> 00:08:34,470
sale.

102
00:08:34,950 --> 00:08:40,620
So I'm going to create another function which is probably going to need to be an asynchronous function

103
00:08:40,620 --> 00:08:47,190
because we're going to be working with the back end in this function to sell our item. This function,

104
00:08:47,190 --> 00:08:49,650
I'm going to call it as a sellItem.

105
00:08:50,340 --> 00:08:57,120
And this is what's going to be triggered when the second button click happens.

106
00:08:59,310 --> 00:09:00,690
So we're going to replace that handle

107
00:09:00,690 --> 00:09:05,940
Click here with selIItem and I'm going to console.log

108
00:09:09,130 --> 00:09:10,510
confirm clicked.

109
00:09:10,930 --> 00:09:12,240
Let's try this again.

110
00:09:12,250 --> 00:09:16,210
We click sell, sell clicked. And then I put in a price,

111
00:09:16,270 --> 00:09:19,270
click confirm and confirm gets clicked.

112
00:09:20,170 --> 00:09:23,010
We can actually access the price in here as well.

113
00:09:23,020 --> 00:09:27,220
So if I want to console.log the set price,

114
00:09:32,040 --> 00:09:36,330
then I can tap into that variable called price right here.

115
00:09:36,990 --> 00:09:40,860
And if I click on sell, give it a price, click confirm,

116
00:09:41,190 --> 00:09:45,540
you can see my setPrice is available right here for me to do something with.

117
00:09:46,320 --> 00:09:48,330
So what's the next thing I want to do?

118
00:09:48,360 --> 00:09:57,960
Well, I want to be able to list this item in my main canister and keep track of it somewhere in a Hash

119
00:09:57,960 --> 00:10:04,410
Map so that I'll know which of these items are listed and how much they're listed for and who it belongs

120
00:10:04,410 --> 00:10:04,740
to.

121
00:10:05,400 --> 00:10:07,890
So that's what's going to happen in my sellItem function,

122
00:10:08,100 --> 00:10:10,530
but first, we have to write the logic on the backend.

123
00:10:11,490 --> 00:10:15,090
I'm going to create a new public shared function

124
00:10:16,380 --> 00:10:22,680
because this is going to allow me to get hold of the caller's id, which is going to be the user who

125
00:10:22,680 --> 00:10:23,970
owns that NFT.

126
00:10:24,570 --> 00:10:29,910
And that's going to be really helpful when I set the owner of the NFT in the sale listing.

127
00:10:30,360 --> 00:10:35,670
Now I'm going to call this function listItem and it's going to take two inputs.

128
00:10:36,330 --> 00:10:42,960
One is the id which is going to be a principal type of the NFT that's being listed.

129
00:10:43,560 --> 00:10:51,450
And secondly, it's the price as a Nat or a natural number, which will determine how much that price

130
00:10:51,450 --> 00:10:52,440
is listed for,

131
00:10:52,560 --> 00:10:55,050
so the two key pieces of information,

132
00:10:55,050 --> 00:10:55,320
right?

133
00:10:55,890 --> 00:11:02,220
And what this function is going to do is we're going to create a HashMap up here.

134
00:11:02,370 --> 00:11:05,460
So we've got a map of NFTs, map of owners,

135
00:11:05,820 --> 00:11:09,450
but we're going to create another one, which is going to keep track of all the listings.

136
00:11:09,570 --> 00:11:12,870
And that function is going to add to that HashMap.

137
00:11:13,200 --> 00:11:21,720
We're going to call this mapOfListings, and it's going to be a HashMap.HashMap.

138
00:11:22,350 --> 00:11:28,680
Now, the data type of the key is going to be a principal because it's going to be the principal ID

139
00:11:29,010 --> 00:11:31,440
of the listed NFT.

140
00:11:32,220 --> 00:11:41,070
And the value that that is going to map to is going to be a custom type because we want to hold a bunch

141
00:11:41,070 --> 00:11:46,110
of information. We want to hold the owner's ID, we want to hold the price,

142
00:11:46,500 --> 00:11:54,330
and maybe in the future you'd even want to hold things like the historic record of sales, what price

143
00:11:54,330 --> 00:11:59,640
it was when it first sold, what price it was when it was sold the next time, what date stamp that

144
00:11:59,640 --> 00:12:02,070
happened on, and a whole bunch of complex things.

145
00:12:02,280 --> 00:12:06,660
But for now, we're going to keep it quite simple just so that you can see how it's done.

146
00:12:07,710 --> 00:12:10,380
So I'm going to create a private type.

147
00:12:10,950 --> 00:12:16,710
So this is a new data type that I'm creating here, which is going to be called Listing.

148
00:12:17,430 --> 00:12:19,980
And this is how you would create a new data type.

149
00:12:19,980 --> 00:12:26,370
So you give it a name with a capital letter to begin with, equals, and then a set of curly braces.

150
00:12:27,120 --> 00:12:30,510
Now, inside here, we get to define all of its properties.

151
00:12:31,500 --> 00:12:33,450
So what is the Listing going to hold?

152
00:12:33,870 --> 00:12:41,280
Well, it's going to hold the item owner, which is going to be of a principal type.

153
00:12:41,820 --> 00:12:44,670
And then we close it off with a semicolon.

154
00:12:45,390 --> 00:12:51,510
And then it's going to hold the item price as well, which is going to be a natural number.

155
00:12:52,200 --> 00:12:59,160
And if we add a semicolon here, then that error will go away and we can add this listing as the data

156
00:12:59,160 --> 00:13:00,810
type of the value.

157
00:13:01,530 --> 00:13:07,950
Again, we're going to initialize our HashMap in the same way as before because our principal equal

158
00:13:07,950 --> 00:13:16,560
checks for the key equality and principal hash will hash all keys for us when we create new items. Down

159
00:13:16,560 --> 00:13:19,260
here in our listItem function,

160
00:13:19,500 --> 00:13:25,830
we're going to get hold of the item, the actual NFT, from our map of NFTs.

161
00:13:26,100 --> 00:13:34,020
And because we're not sure if a particular NFT actually exists, then we have to do what we did before,

162
00:13:34,020 --> 00:13:38,700
which is use this switch statement to unwrap that optional.

163
00:13:39,660 --> 00:13:46,250
So I'm going to create a new variable called item and it's going to have a data type of the NFTActor

164
00:13:46,260 --> 00:13:55,500
Class.NFT, and it's going to be equal to a switch statement that's going to switch on,

165
00:13:55,890 --> 00:14:04,350
looking through the map of NFTs, calling the .get function and then getting the NFT with this ID

166
00:14:04,500 --> 00:14:05,340
that's passed in.

167
00:14:06,630 --> 00:14:14,760
Now we get to specify in the case where it's null, where that ID doesn't exist as a key in the map

168
00:14:14,760 --> 00:14:15,660
of NFTs,

169
00:14:16,170 --> 00:14:22,800
well, in that case, we're actually going to return not an NFT, but we're actually going to use the

170
00:14:22,800 --> 00:14:30,750
return keyword to output some piece of text. So we can make our function have a return in the form

171
00:14:30,750 --> 00:14:31,440
of text.

172
00:14:32,130 --> 00:14:37,590
And if in the case where we can't find the item with the id that was passed, then we're actually

173
00:14:37,590 --> 00:14:39,480
going to exit the rest of the function.

174
00:14:39,480 --> 00:14:41,550
We're not going to continue because there's no point.

175
00:14:41,970 --> 00:14:49,890
And we're going to return a piece of text telling the frontend that the NFT does not exist.

176
00:14:50,970 --> 00:14:55,200
That way we might be able to give that as feedback to the user or do something with it.

177
00:14:55,680 --> 00:15:03,390
In the other case where we have the result existing, then we're going to do our usual thing where we

178
00:15:03,390 --> 00:15:04,560
say case,

179
00:15:04,570 --> 00:15:12,390
if it's a optional result and it does exist, then we're going to return the actual result. And we need

180
00:15:12,390 --> 00:15:15,510
some semicolons at the end of all of these

181
00:15:15,620 --> 00:15:21,110
lines. And it's angry with us because we don't have a return statement.

182
00:15:21,530 --> 00:15:30,110
So for now, I'm just going to return the word Success just to stop the error messages from bugging

183
00:15:30,110 --> 00:15:30,410
me.

184
00:15:31,280 --> 00:15:38,840
So the next thing we want to do is we want to get hold of the owner of this NFT that we are pulling

185
00:15:38,840 --> 00:15:45,110
up because we want to make sure that not just anyone is calling this list item method.

186
00:15:45,530 --> 00:15:52,220
We have to check that the person who's calling it, the msg.caller, is the same person as the owner

187
00:15:52,250 --> 00:15:56,210
of the item that's listed in our map of NFTs.

188
00:15:56,750 --> 00:16:04,190
Now, once we've gotten hold of our item which is our NFTActorClass here, we can call that method

189
00:16:04,430 --> 00:16:15,200
getOwner in order to check the stored owner of that NFT. So we can say let owner = item.get

190
00:16:15,410 --> 00:16:15,980
Owner.

191
00:16:18,030 --> 00:16:26,520
In our if statement, we can check to see if the owner is the same as the msg.caller. And using that

192
00:16:26,520 --> 00:16:34,200
method from the principal data type equal, we can perform that check quite easily. So we can say principal

193
00:16:35,700 --> 00:16:40,710
.equal and we can pass in two values.

194
00:16:41,040 --> 00:16:45,840
First is the owner and second is the msg.caller.

195
00:16:46,620 --> 00:16:53,340
And now, if this if statement is true, then that means it's the actual owner who is calling this,

196
00:16:53,340 --> 00:16:56,250
which means this is allowed and we can list the item.

197
00:16:56,820 --> 00:17:02,610
But if that statement is not true, then that means it's just some random person trying to list somebody

198
00:17:02,610 --> 00:17:04,859
else's NFT, which should not be allowed.

199
00:17:05,280 --> 00:17:07,839
So in that case, we're just simply going to return

200
00:17:08,700 --> 00:17:15,089
'You don't own the NFT,' which sounds a little bit harsh, but I think it gets to the point.

201
00:17:16,380 --> 00:17:23,490
Now, if this is the case, though, we're going to create that new listing inside our map of listings.

202
00:17:24,180 --> 00:17:29,310
We can create the new listing item, newListing,

203
00:17:30,120 --> 00:17:34,470
and this is going to be of data type Listing.

204
00:17:35,010 --> 00:17:42,830
And we can set it equal to a new set of curly braces and we'll set each of these attributes,

205
00:17:42,840 --> 00:17:44,910
so itemOwner and itemPrice.

206
00:17:45,510 --> 00:17:52,380
So itemOwner is going to be equal to the owner that we got back just now, because we've checked that

207
00:17:52,380 --> 00:18:00,300
these are the same, and the itemPrice, more importantly, is going to be the price that was passed

208
00:18:00,300 --> 00:18:01,200
in over here.

209
00:18:03,150 --> 00:18:10,290
And once we've created our Listing, we can then put it into the mapOfListings.put, and we're

210
00:18:10,290 --> 00:18:19,980
going to put in the key as the id of the item that's being listed and the value being the newListing

211
00:18:19,980 --> 00:18:21,570
that we created just now.

212
00:18:22,170 --> 00:18:29,670
And we can cut this success return to below here, because that's really the only time when it should

213
00:18:29,670 --> 00:18:31,020
be successful.

214
00:18:31,650 --> 00:18:36,480
And if we add a semicolon here, then that error message should go away.

215
00:18:37,320 --> 00:18:44,010
And here it's telling me expression of type async principal cannot produce expected type of principal,

216
00:18:44,340 --> 00:18:50,610
which makes me think that this is currently still a promise that's not realized because we forgot,

217
00:18:50,850 --> 00:18:53,340
I forgot to add the await keyword here.

218
00:18:54,060 --> 00:18:57,090
So this should be the final code of our listing

219
00:18:57,480 --> 00:18:59,670
and it does a couple of important things.

220
00:19:00,120 --> 00:19:08,940
One is it checks that the person who's actually calling this method to list an NFT is the actual owner

221
00:19:08,940 --> 00:19:17,340
of the NFT because the msg.caller has to contain your ID and we check it against the owner of the

222
00:19:17,340 --> 00:19:17,970
NFT.

223
00:19:18,630 --> 00:19:24,060
The second thing that it does is it creates this new listing, which seems a little bit overkill for

224
00:19:24,060 --> 00:19:25,740
our two pieces of information.

225
00:19:26,190 --> 00:19:32,610
But if you were to extend this project, then you would add in the timestamp of the sale or keep track

226
00:19:32,610 --> 00:19:38,100
of the historical prices and a whole bunch of other things that you could do in here.

227
00:19:38,520 --> 00:19:43,650
But now that we've created this function, let's go back to our frontend and actually call it.

228
00:19:44,160 --> 00:19:48,480
So inside our sellItem function, we're going to call that method.

229
00:19:48,780 --> 00:19:50,160
So we're going to say await,

230
00:19:50,520 --> 00:19:56,270
and then we need to call the opend canister which we have yet to import.

231
00:19:56,280 --> 00:19:57,690
So let's add that.

232
00:19:58,200 --> 00:20:10,170
So import open curly braces, opend and it's going to be from three of these ../ declarations/

233
00:20:10,170 --> 00:20:10,970
opend.

234
00:20:12,060 --> 00:20:21,540
Now we can call that method await opend.listItem, and we have to provide our two pieces of

235
00:20:21,540 --> 00:20:22,320
information:

236
00:20:22,680 --> 00:20:24,930
the id of the NFT and the price.

237
00:20:25,590 --> 00:20:29,670
So the id is going to come from our props here,

238
00:20:29,670 --> 00:20:30,720
so props.id.

239
00:20:35,290 --> 00:20:41,380
And the price is of course going to come from our priceInput when we said it here.

240
00:20:43,410 --> 00:20:51,480
Now I'm going to save the output as a listingResult, and for now I'm just going to console.log it.

241
00:20:59,000 --> 00:20:59,390
Like

242
00:20:59,510 --> 00:21:06,200
so. In order to test this out because we've changed the back end, we're going to have to redeploy

243
00:21:06,200 --> 00:21:07,220
our canister.

244
00:21:07,910 --> 00:21:16,610
I'm going to go ahead and go to my read me and scroll up to where I've got the deploy canisters code

245
00:21:16,940 --> 00:21:19,010
and I'm going to copy all of this,

246
00:21:19,370 --> 00:21:21,500
paste it in here and hit enter.

247
00:21:21,890 --> 00:21:28,130
Now, once that's all deployed, if we head back and refresh our website, we should have nothing in

248
00:21:28,130 --> 00:21:37,100
our collection because it's all reset. So we can mint a new NFT here, give it a name, and once it's

249
00:21:37,100 --> 00:21:42,020
minted, we can go over to all my NFTs and click the sell button.

250
00:21:42,620 --> 00:21:44,840
So I'm going to set a price on it,

251
00:21:45,020 --> 00:21:53,480
click confirm and it tells me invalid Nat argument 12. And you see how it's got the quotation marks around

252
00:21:53,480 --> 00:21:58,190
the 12, which gives me an idea of where the bug might be.

253
00:21:58,670 --> 00:22:05,270
Now I hope you don't mind me showing you all these bugs, because from my experience of building, especially

254
00:22:05,270 --> 00:22:12,500
this NFT project, which is really, really quite big, I've come across a lot of different error codes

255
00:22:12,500 --> 00:22:18,470
and a lot of different problems and a lot of different bugs, which, you know, you'll probably make

256
00:22:18,470 --> 00:22:18,980
as well.

257
00:22:19,100 --> 00:22:24,650
And I think it's quite helpful to see the error messages and have me just sort of translate to what they

258
00:22:24,650 --> 00:22:29,320
mean in case it happens to you as well when you're developing your own projects.

259
00:22:30,020 --> 00:22:35,720
So in this case, it's saying this is not a Nat basically. This 12 is a string.

260
00:22:36,500 --> 00:22:43,400
So if we go down to the part where we actually passed over the price, if instead of passing over as

261
00:22:43,880 --> 00:22:51,260
just a string, we actually wrap it inside this number converter, then it's going to convert it into

262
00:22:51,260 --> 00:22:52,640
a number data type.

263
00:22:52,850 --> 00:22:54,410
So let's try that again.

264
00:22:57,490 --> 00:23:04,390
And this time we're getting our listing success come back, which means that everything actually worked

265
00:23:04,390 --> 00:23:09,520
and we've got our newly listed item into our map of listings.

266
00:23:10,360 --> 00:23:13,810
Now, what else needs to happen when you sell an item?

267
00:23:13,840 --> 00:23:21,520
Well, you need to transfer this item over to the platform, and the platform needs to hold on to it.

268
00:23:21,760 --> 00:23:28,360
And the reason for this is because, similar to how we did this check here making sure that the person

269
00:23:28,360 --> 00:23:33,190
who's calling this list item is the same person that owns the NFT,

270
00:23:33,580 --> 00:23:37,390
we want to do the same thing in here when we do the transfer function.

271
00:23:37,540 --> 00:23:44,230
We want to make sure that we only transfer the item if that transfer function is being called by the

272
00:23:44,230 --> 00:23:45,730
owner of the NFT.

273
00:23:46,570 --> 00:23:51,010
That's the next function that we have to write, and I'm going to do it at the bottom here.

274
00:23:51,370 --> 00:23:54,370
Again, it's going to be a public shared function,

275
00:23:55,470 --> 00:23:57,500
so that we can tap into the msg.

276
00:23:57,700 --> 00:24:03,060
caller. And this function is going to be called transferOwnership.

277
00:24:05,880 --> 00:24:08,160
Now it's going to take two inputs:

278
00:24:08,430 --> 00:24:13,680
one is the new owner's id, so newOwner,

279
00:24:15,580 --> 00:24:17,830
which is going to be a principal data type.

280
00:24:18,070 --> 00:24:26,740
And this function is going to return a piece of text to let us know whether if the transfer went through

281
00:24:26,950 --> 00:24:27,760
successfully.

282
00:24:28,090 --> 00:24:34,090
Now, the first thing we're going to do is similar to what we did before, which is to check and make

283
00:24:34,090 --> 00:24:37,210
sure that when we're performing this transfer,

284
00:24:37,510 --> 00:24:42,340
this method is actually being called by the owner of the NFT.

285
00:24:43,150 --> 00:24:50,920
To do that, all we have to do is say msg.caller and check that it's equal to the NFT owner,

286
00:24:50,920 --> 00:24:54,130
which is set as the owner of this NFT.

287
00:24:54,910 --> 00:24:56,920
Now, if this is not true,

288
00:24:56,950 --> 00:25:02,620
so if there's an else statement, now means this person doesn't actually own the NFT.

289
00:25:02,860 --> 00:25:05,440
So we're simply going to stop and return,

290
00:25:05,800 --> 00:25:11,470
and because we've got this output text, we're going to give the frontend an error message and say that

291
00:25:11,800 --> 00:25:16,120
'Not initiated by an NFT owner.'

292
00:25:16,990 --> 00:25:20,680
But inside this if statement though, we're going to go ahead with the transfer.

293
00:25:21,190 --> 00:25:28,420
So the transfer basically involves setting this NFT owner to the newOwner that's passed in, which

294
00:25:28,420 --> 00:25:31,210
means we have to change this to a var.

295
00:25:31,570 --> 00:25:36,700
Now, it's generally not a good idea to leave these global vars lying around where it could be changed

296
00:25:36,700 --> 00:25:38,920
by other classes or other actors.

297
00:25:39,250 --> 00:25:42,400
So we're going to make all of these properties private.

298
00:25:47,420 --> 00:25:51,970
That way we can only update these properties within the NFT itself.

299
00:25:51,980 --> 00:25:57,620
And in the case of the NFT owner, that means only through this transferOwnership function.

300
00:25:58,250 --> 00:26:05,060
So we're going to set the NFT owner using that sort of weird syntax which is the := to the

301
00:26:05,060 --> 00:26:07,190
new owner that's passed in.

302
00:26:08,330 --> 00:26:16,250
And once this is done, we're going to return success so that our frontend knows that the transfer

303
00:26:16,250 --> 00:26:17,540
went through successfully.

304
00:26:17,990 --> 00:26:28,730
Now let's hit save and close down this file and go to our read me and go ahead and deploy and update all

305
00:26:28,730 --> 00:26:32,600
our canisters using the command line code in here.

306
00:26:33,200 --> 00:26:35,120
Coming back to our item,

307
00:26:35,600 --> 00:26:39,890
once we've gotten a success back from the Listing result...

308
00:26:42,950 --> 00:26:48,080
Now I'm just using text here just to make it easier for you to see what's actually going on so we can

309
00:26:48,080 --> 00:26:50,000
follow it sort of roughly in English.

310
00:26:50,360 --> 00:26:57,860
But of course, if you want to do this in terms of error codes or success codes or any other way of

311
00:26:57,890 --> 00:26:59,840
checking the output, you can.

312
00:27:00,470 --> 00:27:07,970
But here, it's pretty clear that if the listing process went through correctly, then we're going to

313
00:27:07,970 --> 00:27:09,440
make the transfer.

314
00:27:10,010 --> 00:27:16,490
The transfer is going to call a method, the transferOwnership, on the NFT itself.

315
00:27:17,150 --> 00:27:20,840
And we already accessed the NFT itself up here when

316
00:27:21,240 --> 00:27:26,900
we created that agent and then we loaded up the NFTActorClass through this line.

317
00:27:27,470 --> 00:27:36,500
So we can simply piggyback off that by creating a new let variable called the NFTActor

318
00:27:37,040 --> 00:27:44,540
and then over here we get rid of the const keyword and simply assign it to this variable.

319
00:27:45,320 --> 00:27:56,330
So that means down here, we can then use it and use our await NFTActor.transferOwnership.

320
00:27:57,350 --> 00:28:03,500
Now the input that our transferOwnership function takes is the principal ID of the new owner.

321
00:28:03,740 --> 00:28:06,500
So who is going to be the new owner?

322
00:28:06,950 --> 00:28:10,430
Well, it's going to be our OpenD canister.

323
00:28:11,060 --> 00:28:20,090
So it'd be great if we get hold of its id. If we create a new function in here, which will be public

324
00:28:20,480 --> 00:28:23,600
query func,

325
00:28:23,990 --> 00:28:25,430
and we can call it

326
00:28:25,430 --> 00:28:29,170
getOpenDCanisterID.

327
00:28:29,190 --> 00:28:34,940
Quite wordy again, but good for readability.

328
00:28:35,570 --> 00:28:40,160
And then we can return its ID as a principal.

329
00:28:41,960 --> 00:28:48,650
Now, as you've seen before, we can use the principal.fromActor method in order to get the principal

330
00:28:48,650 --> 00:28:51,020
ID of a particular actor.

331
00:28:51,530 --> 00:29:01,370
Then we can simply just write principal.fromActor and pass in the name of this actor, which

332
00:29:01,370 --> 00:29:02,270
is OpenD.

333
00:29:03,590 --> 00:29:07,850
And if I add a semicolon, then I should get rid of my errors,

334
00:29:08,180 --> 00:29:12,350
and I can now go over here and get hold of the OpenD

335
00:29:14,770 --> 00:29:15,160
Id.

336
00:29:21,590 --> 00:29:23,990
Which is going to be through await

337
00:29:24,020 --> 00:29:25,430
opend.

338
00:29:25,520 --> 00:29:27,210
get--

339
00:29:28,140 --> 00:29:30,010
getOpenDCanisterId.

340
00:29:30,530 --> 00:29:31,970
I'm just going to copy and paste it.

341
00:29:33,170 --> 00:29:39,650
And once we got hold of that, that's what we going to be passing in to our transferOwnership as the

342
00:29:39,680 --> 00:29:40,580
new owner.

343
00:29:41,060 --> 00:29:46,460
Now, finally, because we're going to get a output from this, we're going to create a new constant

344
00:29:46,460 --> 00:29:54,350
called the transferResults to capture the text that gets sent back after this method is called.

345
00:29:55,070 --> 00:29:58,850
And as usual, I'm just going to console.log it.

346
00:30:02,710 --> 00:30:07,750
Now, before we can test our code, we're going to need to deploy again.

347
00:30:07,960 --> 00:30:13,930
So make sure that you save bothyoru nft.mo file and your main.mo file using command +

348
00:30:13,930 --> 00:30:16,540
s on Mac or control + s on Windows.

349
00:30:16,870 --> 00:30:19,690
Then go ahead and redeploy your canisters.

350
00:30:21,050 --> 00:30:24,320
So again, either heading into the read me or if you click up,

351
00:30:24,590 --> 00:30:27,080
it should still be the last command that you had run.

352
00:30:27,470 --> 00:30:31,460
Just simply run the deploy so that all our canisters get updated.

353
00:30:32,120 --> 00:30:37,220
Now, once it's deployed, we can head over Mint a new item.

354
00:30:37,490 --> 00:30:41,430
And if we try to sell it, you're going to see an error right now.

355
00:30:41,450 --> 00:30:49,370
So when I click confirm and now when we try to sell this new item, then it tells you that the error

356
00:30:49,490 --> 00:30:52,040
here is 'Fail to verify certificate.'

357
00:30:52,550 --> 00:30:58,610
So I did quite a lot of digging around this error code, and it turns out that the issue is related

358
00:30:58,610 --> 00:31:00,500
to our dfinity agent.

359
00:31:01,190 --> 00:31:07,220
According to the documentation, by default, the agent is configured to talk to the main live internet

360
00:31:07,220 --> 00:31:12,310
computer blockchain and verifies the response using a hardcoded public key.

361
00:31:12,710 --> 00:31:16,250
But it's not going to work when we're doing it locally.

362
00:31:16,520 --> 00:31:22,340
So in order to get around that issue when we're doing local deployment, because let's face it, none

363
00:31:22,340 --> 00:31:28,610
of us have enough ICP tokens to be deploying these canisters on the Internet computer.

364
00:31:28,910 --> 00:31:34,910
Because remember, every single time we're minting an NFT that is creating a new canister, and if we're

365
00:31:34,910 --> 00:31:40,880
doing it live on the Internet computer, that's another $5 or $10 for every single time we're testing

366
00:31:40,880 --> 00:31:41,000
it.

367
00:31:41,030 --> 00:31:44,030
So luckily, we don't have to spend that money.

368
00:31:44,330 --> 00:31:49,370
We're doing it locally and we can simply fix this by going over here and calling

369
00:31:49,700 --> 00:31:52,100
agent.fetchRootKey

370
00:31:54,720 --> 00:31:56,940
which is spelt like this.

371
00:31:57,210 --> 00:32:04,050
And this is going to tell it that while we're working locally, simply just to fetch the route key and

372
00:32:04,050 --> 00:32:05,700
ignore the situation.

373
00:32:06,120 --> 00:32:13,380
But it's important to remember that when deploying this project live, we should remove the following

374
00:32:13,380 --> 00:32:13,770
line.

375
00:32:14,940 --> 00:32:16,950
So now let's try that again.

376
00:32:16,980 --> 00:32:24,420
And because our transfer already went through, will have to mint another NFT to test it out.

377
00:32:25,020 --> 00:32:31,440
And you can just imagine that ka-ching in the background as we've saved ourselves something like $5

378
00:32:31,440 --> 00:32:35,220
or $10 from minting this NFT and creating this canister.

379
00:32:35,910 --> 00:32:38,850
So let's try selling this one that we actually own.

380
00:32:40,260 --> 00:32:47,130
And once we hit confirm, you should see listing success and transfer success.

381
00:32:47,610 --> 00:32:57,090
So we've actually managed to put NFT onto our HashMap of listings and we've managed to transfer the

382
00:32:57,090 --> 00:33:04,020
ownership over to the OpenD canister so that when somebody buys it, it'll be able to transfer it

383
00:33:04,020 --> 00:33:04,530
to them.

384
00:33:04,980 --> 00:33:12,570
Because remember, the whole point is that only the person who owns the NFT can make the transfer.

385
00:33:13,080 --> 00:33:18,150
And because we're not going to be staying around, you know, waiting for somebody to buy it and then

386
00:33:18,150 --> 00:33:25,050
calling this method, we have to transfer the ownership when we list it to our OpenD website.

387
00:33:25,230 --> 00:33:31,080
So now, even though not much has happened, we've actually written quite a lot of code.

388
00:33:31,590 --> 00:33:34,860
So in the next lesson, we're going to tidy things up a little bit

389
00:33:35,250 --> 00:33:41,310
and we're also going to make sure that when we list an item, we're able to see all the items that are

390
00:33:41,310 --> 00:33:43,800
listed for sale in the Discover section.

391
00:33:44,400 --> 00:33:47,760
So for all of that and more, I'll see you on the next lesson.

