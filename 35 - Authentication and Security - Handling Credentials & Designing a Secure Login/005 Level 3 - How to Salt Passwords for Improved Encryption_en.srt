1
00:00:00,320 --> 00:00:00,860
All right.

2
00:00:00,860 --> 00:00:07,610
So now that we've seen what some of the vulnerabilities might be for hashed passwords, it's time to

3
00:00:07,610 --> 00:00:16,430
level up and learn about a way that we can prevent these types of dictionary attacks or hash table cracks.

4
00:00:16,430 --> 00:00:20,360
And in order to do that, we have to learn about salting.

5
00:00:20,630 --> 00:00:23,000
Now what exactly is salting?

6
00:00:23,000 --> 00:00:25,940
Well, we already know what hashing is,

7
00:00:25,940 --> 00:00:32,870
it's when we take a password, we run it through a hash function, and we end up with a hash that we

8
00:00:32,870 --> 00:00:34,430
store on our database.

9
00:00:34,430 --> 00:00:41,030
And as we saw in the last lesson, passwords that are generated by humans are extremely insecure.

10
00:00:41,030 --> 00:00:46,730
They tend to be very short, and they tend to be dictionary words that are extremely easy to look up

11
00:00:46,730 --> 00:00:48,740
and create a hash table for.

12
00:00:48,770 --> 00:00:52,550
Now salting takes the hashing a little bit further.

13
00:00:52,550 --> 00:01:01,010
In addition to the password, we also generate a random set of characters and those characters, along

14
00:01:01,010 --> 00:01:07,670
with the user's password, gets combined and then put through the hash function, so the resulting hash

15
00:01:07,670 --> 00:01:13,250
is created from both the password as well as that random unique salt.

16
00:01:13,250 --> 00:01:20,210
So that means no matter how simple the password of the user is, adding that salt increases its complexity,

17
00:01:20,210 --> 00:01:26,090
increases the number of characters, and we make our user database a lot more secure.

18
00:01:26,120 --> 00:01:31,850
Consider the previous problem that we saw in the last lesson, where we covered Hacking 101.

19
00:01:31,850 --> 00:01:37,370
Now we know that three of our users have the same password, and we figured that out because they all

20
00:01:37,370 --> 00:01:38,570
had the same hash,

21
00:01:38,570 --> 00:01:47,300
now, on the other hand, if we had generated a random set of characters, which is the salt, and combined

22
00:01:47,300 --> 00:01:53,360
the password with the salt in order to generate the hash, then they won't have the same hash in our

23
00:01:53,360 --> 00:01:54,380
user database.

24
00:01:54,380 --> 00:02:00,890
So let's try and generate Emily's hash from her password so we know that her password is qwerty and

25
00:02:00,890 --> 00:02:02,540
we generate a random salt.

26
00:02:02,540 --> 00:02:07,220
So then let's go ahead and put in her password qwerty,

27
00:02:07,220 --> 00:02:11,840
and then we append at the end that random salt that we generated.

28
00:02:11,840 --> 00:02:14,450
And we end up with a hash.

29
00:02:14,930 --> 00:02:24,500
Now this hash however, is not the same as Tony's hash or Angela's hash, because the salt is different

30
00:02:24,500 --> 00:02:25,430
each time.

31
00:02:25,430 --> 00:02:32,480
Now the salt is something that the user doesn't have to remember, and instead it's stored in the database

32
00:02:32,480 --> 00:02:34,070
along with the hash.

33
00:02:34,070 --> 00:02:40,190
So that means when the user types in their password, when they try to log in, you combine their password

34
00:02:40,190 --> 00:02:41,150
with the salt.

35
00:02:41,150 --> 00:02:45,890
And if you generate the same hash, then they must have had the same password.

36
00:02:45,890 --> 00:02:47,330
It's kind of clever, isn't it?

37
00:02:47,330 --> 00:02:53,240
And on our database, of course, we wouldn't be storing their passwords, but only the salt and the

38
00:02:53,240 --> 00:02:53,720
hash.

39
00:02:53,720 --> 00:02:56,060
Now consider our previous statistics.

40
00:02:56,060 --> 00:03:01,520
You can generate about 20 billion MD5 hashes per second.

41
00:03:01,520 --> 00:03:09,650
So even if we added a salt and we made it harder to generate a hash table with some of the latest GPUs,

42
00:03:09,650 --> 00:03:16,040
you can still probably generate a hash table with all salt combinations relatively quickly.

43
00:03:16,040 --> 00:03:19,760
So what else can we do to increase the security?

44
00:03:19,760 --> 00:03:23,990
Well, we can use something other than MD5, right?

45
00:03:23,990 --> 00:03:30,050
Another hashing algorithm that's valued because it's incredibly slow.

46
00:03:30,050 --> 00:03:32,480
And this is where Bcrypt comes in.

47
00:03:32,480 --> 00:03:40,310
This is one of the industry standard hashing algorithms that developers use to keep their users' passwords

48
00:03:40,310 --> 00:03:40,910
safe.

49
00:03:40,910 --> 00:03:48,950
Because while you can calculate 20 billion MD5 hashes per second, even the latest and the greatest

50
00:03:48,950 --> 00:03:56,990
GPUs can still calculate only about 17,000 Bcrypt hashes per second, which makes it dramatically harder

51
00:03:56,990 --> 00:04:05,060
for a hacker to generate those precompiled hash tables and a salted hash table instead of taking something

52
00:04:05,060 --> 00:04:11,180
like three seconds if it was hashed with MD5, if it was hashed using Bcrypt, it would take you something

53
00:04:11,180 --> 00:04:14,870
like eight months, which is not really worth a hacker's while.

54
00:04:14,870 --> 00:04:20,990
They'll probably go and search out a company that has less security enabled, and to make our passwords

55
00:04:20,990 --> 00:04:28,370
even more secure when we're using Bcrypt, it has a concept of what's called salt rounds, how many

56
00:04:28,370 --> 00:04:31,280
rounds you're going to salt your password with.

57
00:04:31,280 --> 00:04:36,920
And obviously, the more rounds you do, the saltier your password, and also the more secure it is

58
00:04:36,920 --> 00:04:37,940
from hackers.

59
00:04:37,940 --> 00:04:40,370
What exactly are salt rounds?

60
00:04:40,370 --> 00:04:48,650
Well, let's say that our original user password was qwerty, and we generate a random set of characters

61
00:04:48,650 --> 00:04:49,820
as the salt.

62
00:04:50,480 --> 00:04:53,720
So now we have qwerty and a random set of salt.

63
00:04:53,720 --> 00:04:58,910
We pass it through our hash function Bcrypt and we end up with a hash,

64
00:04:59,000 --> 00:04:59,690
now that's

65
00:05:00,000 --> 00:05:01,770
one round of salting,

66
00:05:01,770 --> 00:05:08,640
if we wanted to have two rounds of salting, then we take the hash that was generated in round one and

67
00:05:08,640 --> 00:05:11,490
we add the same salt from before,

68
00:05:11,490 --> 00:05:17,820
and now we run it through Bcrypt the hash function again, and we end up with a different hash.

69
00:05:17,820 --> 00:05:23,040
And the number of times you do this is the number of salt rounds.

70
00:05:23,040 --> 00:05:30,930
Now the reason why this is genius is because as computers get faster, remember that Moore's Law says

71
00:05:30,930 --> 00:05:37,920
that every year the number of transistors in a computer chip almost doubles, and the cost of that faster

72
00:05:37,920 --> 00:05:39,210
computer halves.

73
00:05:39,210 --> 00:05:43,410
So every year you can get more computing power for less money.

74
00:05:43,410 --> 00:05:45,540
And this is where salt rounds comes in,

75
00:05:45,540 --> 00:05:52,530
when you're hashing your passwords using Bcrypt, you can set the number of rounds you want to salt

76
00:05:52,530 --> 00:05:53,400
your password.

77
00:05:53,400 --> 00:06:00,960
So that means maybe this year in 2019 you salt it 10 rounds, but maybe next year you can increase

78
00:06:00,960 --> 00:06:02,670
that number to 12.

79
00:06:02,670 --> 00:06:10,350
And for every increase in that number, the amount of time that it takes to hash your password doubles.

80
00:06:10,350 --> 00:06:17,790
And so that means you don't have to change your hashing algorithm or update your code, other than simply

81
00:06:17,790 --> 00:06:20,670
changing one number to keep up with the times.

82
00:06:20,670 --> 00:06:27,810
So just to review, coming back to that user database, we'll have each user's username stored,

83
00:06:27,810 --> 00:06:35,760
we'll have their randomly generated salt stored, and then we'll store their hash after a set number

84
00:06:35,760 --> 00:06:36,990
of salting rounds.

85
00:06:38,070 --> 00:06:43,140
And when it comes to checking their password, when they log in, we'll take the password that they

86
00:06:43,140 --> 00:06:49,320
put in, combine it with the salt that's stored in the database, and run it through the same number

87
00:06:49,320 --> 00:06:55,800
of salting rounds until we end up with the final hash, and we compare the hash against the one that's

88
00:06:55,800 --> 00:07:00,660
stored in the database to see if they've entered the correct password.

89
00:07:00,660 --> 00:07:09,120
Let's give that a go in real life and implement Bcrypt and salting rounds into our website's authentication.

90
00:07:09,240 --> 00:07:15,810
The package that we're going to be using to hash our passwords using Bcrypt is also called bcrypt,

91
00:07:15,810 --> 00:07:20,160
and you can find the documentation for it, as always on NPM.

92
00:07:20,160 --> 00:07:30,420
Now let's try and apply this knowledge to our project, and add hashing and salting into our password

93
00:07:30,420 --> 00:07:34,380
storage and make it a little bit more secure.

94
00:07:34,530 --> 00:07:40,530
Go ahead and download and extract the project file for this lesson.

95
00:07:40,530 --> 00:07:47,130
And once you have extracted it and opened it in VS Code, it should be 9.2 Authentication Lv.2,

96
00:07:47,160 --> 00:07:54,360
take a look inside the index.js, you'll see that we have all of the code that came from the solution

97
00:07:54,360 --> 00:07:58,620
code at the end of the previous lesson.

98
00:07:58,620 --> 00:08:04,620
So there's no hashing or anything happening here just yet,

99
00:08:04,620 --> 00:08:07,290
and we're going to implement that very quickly.

100
00:08:07,290 --> 00:08:10,140
Take a look inside the package.json,

101
00:08:10,140 --> 00:08:13,470
you'll notice that there is a new dependency added,

102
00:08:13,470 --> 00:08:14,850
and that's bcrypt.

103
00:08:14,850 --> 00:08:21,750
Bcrypt is a way for us to be able to hash our passwords using the Blowfish algorithm, which is a super

104
00:08:21,750 --> 00:08:29,640
secure, very modern way of ensuring that nobody with current computational skills should be able to

105
00:08:29,640 --> 00:08:33,330
decode our password in a reasonable amount of time.

106
00:08:33,720 --> 00:08:39,750
It is something that is industry standard, and we're going to use it in our project.

107
00:08:39,750 --> 00:08:49,020
As always, first of all, cd into the correct project and then use "npm install" to add all of the node

108
00:08:49,020 --> 00:08:49,830
modules.

109
00:08:50,730 --> 00:08:51,180
All right.

110
00:08:51,180 --> 00:08:55,680
So the first thing we need to do is to import that bcrypt module.

111
00:08:55,680 --> 00:08:59,190
So, import bcrypt from "bcrypt";

112
00:08:59,700 --> 00:09:07,080
And one thing we should define before we start using it is the number of salting rounds.

113
00:09:07,080 --> 00:09:09,360
So we'll call that saltRounds,

114
00:09:09,360 --> 00:09:11,880
and I'm going to set it to 10.

115
00:09:12,000 --> 00:09:18,480
It depends on your own individual sort of level of security you want for your app,

116
00:09:18,480 --> 00:09:25,920
but obviously, as we explained, the more rounds of salting that happens, the more computation and more

117
00:09:25,920 --> 00:09:33,270
time therefore is required to try and hack the original password out of the hash.

118
00:09:33,270 --> 00:09:39,360
So if we only did two salt rounds, it would take less time to generate the hash,

119
00:09:39,360 --> 00:09:48,570
but it would also probably allow some bad actors to be able to figure out the original password by brute

120
00:09:48,570 --> 00:09:50,910
forcing a lot quicker.

121
00:09:51,780 --> 00:09:54,120
So we've imported bcrypt,

122
00:09:54,120 --> 00:09:57,000
we've added our number of salt rounds,

123
00:09:57,030 --> 00:10:05,010
the next thing we're going to do is to actually use it. Coming into our register POST route right here,

124
00:10:05,010 --> 00:10:07,920
we've got all of our previous code,

125
00:10:07,920 --> 00:10:17,190
but now after we check and make sure that the user doesn't already exist and we're about to save their

126
00:10:17,190 --> 00:10:24,840
email and password into our database, just before that happens, we're going to do our password hashing,

127
00:10:25,170 --> 00:10:28,560
and we're going to do that by using the bcrypt module

128
00:10:28,560 --> 00:10:32,880
and it has a method called hash().

129
00:10:33,960 --> 00:10:37,320
Now this method takes a number of inputs.

130
00:10:37,320 --> 00:10:43,380
So the first one is the data that you want to hash, which is the password that the user typed into

131
00:10:43,380 --> 00:10:44,160
the form.

132
00:10:44,190 --> 00:10:46,620
Next is the number of salt rounds.

133
00:10:46,620 --> 00:10:52,470
So we already have that defined as a constant up top which I said 10 in my case,

134
00:10:52,470 --> 00:10:54,630
and it works out on a couple of computers

135
00:10:54,630 --> 00:10:58,140
we tried to be good enough in terms of speed.

136
00:10:58,530 --> 00:11:05,040
And then finally we have our callback which can return an error, and if there were no errors, then

137
00:11:05,040 --> 00:11:10,830
it will return the encrypted string, which we're going to call the hash.

138
00:11:11,070 --> 00:11:13,410
So let's create this callback.

139
00:11:13,410 --> 00:11:22,110
And once we have that hash then the next step is to store that into our database instead of the plain

140
00:11:22,110 --> 00:11:23,310
text password.

141
00:11:23,310 --> 00:11:30,540
So I'm going to take all of this code up to the res.render()and put it inside this callback.

142
00:11:31,200 --> 00:11:38,100
Now remember that because we are waiting on this query to complete without any errors, before we

143
00:11:38,100 --> 00:11:45,990
res.render(secrets.ejs), we have to turn this callback into an asynchronous method by adding the async

144
00:11:45,990 --> 00:11:47,250
keyword before it.

145
00:11:48,180 --> 00:11:53,820
So now we're ready to replace this password with the hash that gets generated here.

146
00:11:54,540 --> 00:12:03,150
And if there were any errors through the hashing process, then we need to either handle it or at the

147
00:12:03,150 --> 00:12:09,060
very least we need to console.log() it just so that while we're testing, we know what's going on.

148
00:12:14,970 --> 00:12:22,770
And if there were no errors, then we're going to go ahead and do the rest of the planned parts of saving

149
00:12:22,770 --> 00:12:25,740
that user's hash and email into our database.

150
00:12:26,820 --> 00:12:29,250
Let's go ahead and try this out.

151
00:12:29,280 --> 00:12:33,000
Let's go ahead and start our index.js.

152
00:12:33,030 --> 00:12:35,130
Go back to our website.

153
00:12:35,130 --> 00:12:36,480
Go to the home page.

154
00:12:36,480 --> 00:12:38,850
Try to register a new user.

155
00:12:38,850 --> 00:12:41,550
So I'm just going to call it maybe test.

156
00:12:41,550 --> 00:12:44,190
And then the password is still the same.

157
00:12:44,190 --> 00:12:45,870
It's 123456.

158
00:12:45,870 --> 00:12:48,060
And then I'm going to click Register.

159
00:12:48,210 --> 00:12:56,820
So now if I go to my database and I right-click on the users to View all of them, I should now have

160
00:12:56,820 --> 00:12:59,520
a new user, test@gmail.com,

161
00:12:59,520 --> 00:13:01,650
and the password,

162
00:13:01,650 --> 00:13:07,170
as you can see, even though as you saw me enter it, it was still 123456.

163
00:13:07,170 --> 00:13:09,390
Just public announcement,

164
00:13:09,390 --> 00:13:10,620
"Don't do that."

165
00:13:10,920 --> 00:13:12,750
Try to have a more secure password.

166
00:13:12,750 --> 00:13:19,110
But even though it's super insecure in terms of password, we now have a hash that's generated.

167
00:13:19,110 --> 00:13:20,640
It's super long.

168
00:13:20,640 --> 00:13:26,010
I definitely cannot tell that this is one, two three, four, five, six, and hopefully nobody else

169
00:13:26,010 --> 00:13:30,330
will be able to do, if we managed to do everything correctly.

170
00:13:30,600 --> 00:13:33,750
And that's because we did our hashing correctly.

171
00:13:33,750 --> 00:13:39,360
So now somebody hacks into our database, they'll see this instead of this

172
00:13:39,360 --> 00:13:44,490
and it means we've made life a little bit safer for this user.

173
00:13:45,720 --> 00:13:54,000
I'm going to go ahead and actually delete this first entry for angela@gmail.com, because it no longer

174
00:13:54,000 --> 00:13:57,420
actually follows our password strategy.

175
00:13:57,420 --> 00:14:04,320
So now every new user that gets signed up on our website will have a hash for their password.

176
00:14:04,950 --> 00:14:12,060
Now that we've done our registration and we've hashed our password for storage, the next step is to

177
00:14:12,060 --> 00:14:19,500
figure out how to compare the password that's stored in the database against the password that the user

178
00:14:19,500 --> 00:14:22,050
enters when they try to log in.

179
00:14:22,590 --> 00:14:29,430
Unfortunately, with bcrypt, because we're doing many salting rounds, each time we hash the password,

180
00:14:29,430 --> 00:14:31,200
it will not match.

181
00:14:31,200 --> 00:14:40,410
So we can't simply just compare the stored hash against the hashed version of the login password and

182
00:14:40,410 --> 00:14:41,730
expect them to match.

183
00:14:41,760 --> 00:14:48,240
There's actually an extra layer of security in there with that salting, and each time the hash that's

184
00:14:48,240 --> 00:14:50,130
generated will be different.

185
00:14:50,160 --> 00:14:53,580
How can we then compare those two passwords?

186
00:14:53,610 --> 00:14:58,140
Well, Bcrypt actually comes with a method called compare.

187
00:14:59,250 --> 00:15:02,490
Right here we're going to say bcrypt.

188
00:15:02,490 --> 00:15:06,960
and this is the method that we want to use which is compare().

189
00:15:06,960 --> 00:15:13,560
And this allows us to compare the data which is the data that is to be encrypted.

190
00:15:13,560 --> 00:15:19,650
So the data that comes from the user when they try to log in and then the encrypted, which in this

191
00:15:19,650 --> 00:15:23,550
case is of course the hash that's stored in our database,

192
00:15:23,550 --> 00:15:26,910
and then we end up returning a callback.

193
00:15:26,910 --> 00:15:28,860
So bcrypt.compare,

194
00:15:28,860 --> 00:15:32,820
and the first one is the new password.

195
00:15:32,820 --> 00:15:40,350
So I'm just going to change this to loginPassword so that we're not confused later on in our compare.

196
00:15:41,460 --> 00:15:44,580
So we're comparing the login password,

197
00:15:44,580 --> 00:15:51,090
and we're going to compare it against the result that comes back here which I'm going to change to the

198
00:15:51,090 --> 00:15:53,490
"storedHashedPassword".

199
00:15:53,700 --> 00:15:57,180
And that's the comparison that's going to be made.

200
00:15:57,180 --> 00:16:00,150
Now the order of these two matters a great deal.

201
00:16:00,150 --> 00:16:02,430
So don't put this one here and that one here.

202
00:16:02,430 --> 00:16:03,630
It has to be this way

203
00:16:03,630 --> 00:16:09,300
so that the compare() method knows which one it needs to work with and which one needs to hash.

204
00:16:09,570 --> 00:16:16,680
And then we end up with our callback, which is going to be an error or a result,

205
00:16:18,150 --> 00:16:25,230
and then here we can again handle any errors that occur in this process by console logging.

206
00:16:29,910 --> 00:16:39,060
And if there were no errors, then we're simply going to check to make sure that the result is valid.

207
00:16:39,060 --> 00:16:42,390
Then we're going to console.log(result)

208
00:16:42,390 --> 00:16:47,100
for now. I just want to show you what it actually looks like.

209
00:16:47,820 --> 00:16:50,130
So let's go back to our login page.

210
00:16:50,130 --> 00:16:53,220
Use the user that has a hash password.

211
00:16:53,460 --> 00:16:55,230
Go back to here.

212
00:16:55,230 --> 00:16:59,760
You can see that what got console logged is the result, "true"

213
00:16:59,760 --> 00:17:05,460
which means that all we need to do is to check if that is true,

214
00:17:05,460 --> 00:17:08,880
then we can go ahead and res.render(),

215
00:17:11,310 --> 00:17:18,210
but if it's false then we can again send that they got the incorrect password.

216
00:17:18,210 --> 00:17:21,690
And we can now delete this if and else statement here.

217
00:17:23,690 --> 00:17:24,560
Just to make sure,

218
00:17:24,560 --> 00:17:26,810
let's try that with a wrong password.

219
00:17:26,810 --> 00:17:31,640
I'm going to use the second worst password in the world, which is qwerty.

220
00:17:31,670 --> 00:17:32,840
Click log in.

221
00:17:32,840 --> 00:17:35,060
You can see we get incorrect password.

222
00:17:36,220 --> 00:17:37,060
There you have it.

223
00:17:37,060 --> 00:17:45,460
We've now implemented hashing and salting, and we have made our passwords much, much more secure for

224
00:17:45,460 --> 00:17:46,390
our users.

225
00:17:46,390 --> 00:17:51,430
And even if somebody hacks into our website, they will only be able to see this<

226
00:17:51,430 --> 00:17:57,760
and there is no way for them to be able to get back the original password that's associated with that

227
00:17:57,760 --> 00:17:58,480
email.

228
00:17:58,600 --> 00:18:05,110
And if you want to allow users to log in with email and password, we're at a stage where that's already

229
00:18:05,110 --> 00:18:07,120
pretty secure for the user.

230
00:18:08,080 --> 00:18:11,290
In the next lesson, I'm going to talk about something slightly different.

231
00:18:11,290 --> 00:18:19,060
We're going to talk about how to implement cookies and sessions so that when a user is logged in, they

232
00:18:19,060 --> 00:18:27,790
can log in to access the secret page, but that login is saved as a cookie so that they don't have to

233
00:18:27,790 --> 00:18:28,780
re-log in

234
00:18:28,780 --> 00:18:32,890
if they came back to the website, say within a certain period of time.

235
00:18:33,310 --> 00:18:39,520
And this is pretty common when you try to access Facebook or Gmail, you're not having to enter your

236
00:18:39,520 --> 00:18:41,590
password again and again each time.

237
00:18:41,590 --> 00:18:45,640
And we're going to be able to add that functionality to our website as well.

238
00:18:45,670 --> 00:18:49,570
Keep your eyes peeled in the next lesson as we learn all about that.

239
00:18:49,570 --> 00:18:51,670
So for all of that and more, I'll see you there.

